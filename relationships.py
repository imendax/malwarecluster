#!/usr/bin/python3

"""
Copyright (c) 2015, Joshua Saxe
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name 'Joshua Saxe' nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL JOSHUA SAXE BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

import os
import re
import json
import magic
import hashlib
import requests
import itertools

#from pprint import pprint

from auxiliary import pecheck, getdatabase, readids, comparefiletypes
from similarity import jaccard

def getparentprocess(taskid, exesamples):
    """
    Get SHA256 of task sample and use that to find original malware sample in repo

    Args:
        taskid    : task id
        exesamples: list of all exe malware samples

    Raises:
        None

    Returns:
        path: absolute path of executed malware sample
    """

    taskviewurl = "http://localhost:8090/tasks/view/" + str(taskid)
    headers = {"Authorization": "Bearer WTAIn0HHtRIUlR9_uJkJDg"}

    r = requests.get(taskviewurl, headers=headers)
 
    # Convert 'str' cuckoo output to Python 'dict'
    taskviewjson = json.loads(r.content.decode('utf-8'))

    # Get SHA-256 of analyzed sample
    samplesha256 = taskviewjson['task']['sample']['sha256']

    for path in exesamples:
        if re.search(samplesha256, path):
            return path

def calculatengram(ngram, apiattributes):
    """
    Calculate n-gram APIs at a time and push the bag of calls into a single list.
    This list will be used as attributes rather than the API names themselves

    Args:
        ngram        : number of API names to be considered at a time and hashed
        apiattributes: list of API names that were dynamically called by the
                       task

    Raises:
        None

    Returns:
        ngramlist: list of n-gram APIs
    """

    ngramlist = []

    for index in range(0, len(apiattributes), ngram):
        tempstring = "".join(apiattributes[index: index + ngram])
        ngramlist.append(tempstring)

    return ngramlist 

def extractorderedapi(orderedts, taskdict):
    """
    Extract api calls of each process into a list in order of `orderedts` timestamps

    Args:
        orderedts: list of process / child processes timestamps in ascending order
        taskdict : dict containing process static and api features

    Raises:
        None

    Returns:
        None
    """

    orderedapi = []

    def appendapi(pid):
        templist = []
        for api in taskdict[pid]['api']:
            templist.append(api.decode('utf-8'))
        return templist

    for timestamp in orderedts:
        for pid in taskdict:
            if taskdict[pid]['first_seen'] == timestamp and 'api' in taskdict[pid]:
                orderedapi.extend(appendapi(pid))

    return orderedapi

def extractapicalls(taskprocessdict, taskprocessesinfo):
    """
    Extract api calls according to pid and add to `taskprocessdict`

    Args:
        taskprocessdict  : dict containing task process / child processes
                           static features
        taskprocessesinfo: dict containing task process / child processes info

    Raises:
        None

    Returns:
        taskprocessdict: dict containing process static and api features
    """

    for processinfo in taskprocessesinfo:
        pid = processinfo['pid']

        # Get all api calls of the process having pid = `pid` and store based
        # on the time they were called
        apicalls = {}
        for apiinfo in processinfo['calls']:
            time = apiinfo['time']

            if time not in apicalls:
                apicalls[time] = []

            api = apiinfo['api'].encode('utf-8')
            apicalls[time].append(api)

        # Store timestamps of each api call in ascending order
        orderedts = list(apicalls.keys())
        orderedts.sort()

        # Add api calls to `taskprocessdict` in order as they were first seen
        for ts in orderedts:
            if 'api' not in taskprocessdict[pid]:
                taskprocessdict[pid]['api'] = []

            if type(apicalls[ts]) == list:
                taskprocessdict[pid]['api'].extend(apicalls[ts])
            else:
                taskprocessdict[pid]['api'].append(apicalls[ts])

    return taskprocessdict

def extractstaticfeatures(taskprocessesinfo):
    """
    Extract `process_path`, `process_name`, `first_seen`, `ppid` and `pid`
    from task report

    Args:
        taskprocessesinfo: list of dicts containing info about each spawned
                           process / child process in task

    Raises:
        None

    Returns:
        staticdict: dict with `pid` as key and other features as nested dict
    """

    staticdict = {}

    for processfeatures in taskprocessesinfo:
        pid = processfeatures['pid']

        if pid not in staticdict:
            staticdict[pid] = {}

        staticdict[pid]['ppid'] = processfeatures['ppid']
        staticdict[pid]['first_seen'] = processfeatures['first_seen']
        staticdict[pid]['process_path'] = processfeatures['process_path'].encode('utf-8')
        staticdict[pid]['process_name'] = processfeatures['process_name'].encode('utf-8')

    return staticdict

def handleexe(exesamples, thresholddict, ngram, graph):
    """
    Form edges between exe samples based on the dynamic api calls attribute

    Args:
        exesamples   : absolute paths of all exe malware samples
        thresholddict: dict containing Jaccard Index threshold values
        ngram        : ngram number of api sequences
        graph        : networkx graph object

    Raises:
        None

    Returns:
        graph: populated networkx graph object
    """

    malwareattributes = dict()

    # Read task and error ids of previous cuckoo dispatch
    taskids, errorids = readids()

    reportsurl = "http://localhost:8090/tasks/report/"
    headers = {"Authorization": "Bearer WTAIn0HHtRIUlR9_uJkJDg"}

    for taskid in taskids:
        taskreporturl = reportsurl + str(taskid)

        # Get report for `taskid`
        r = requests.get(taskreporturl, headers=headers)

        # Convert 'str' Cuckoo output to Python 'dict'
        taskreportjson = json.loads(r.content.decode('utf-8'))

        # Get info about all processes related to task from cuckoo task report
        taskprocessesinfo = taskreportjson['behavior']['processes']

        # Extract `process_path`, `process_name`, `first_seen` and `pid` from
        # task report
        taskprocessdict = extractstaticfeatures(taskprocessesinfo)

        # Add dynamic API calls info to `taskprocessdict`
        taskprocessdict = extractapicalls(taskprocessdict, taskprocessesinfo)

        # Find order of processes in task based on their `first_seen`
        orderedts = []
        for pid in taskprocessdict:
            orderedts.append(taskprocessdict[pid]['first_seen'])
        orderedts.sort()

        # Extract api calls in order considering all processes related to task
        apiattributes = extractorderedapi(orderedts, taskprocessdict)
 
        # Calculate n-gram APIs
        apiattributes = calculatengram(ngram, apiattributes)

        # Get parent process (original malware exe process)
        path = getparentprocess(taskid, exesamples)

        # Store dynamic API calls attribute
        malwareattributes[path] = apiattributes

    # Add exe samples' node to graph
    for path in exesamples:
        graph.add_node(path.split('/')[-1], label=os.path.split(path)[-1][:6])

    # Create edge based on Jaccard index
    for malware1, malware2 in itertools.combinations(exesamples, 2):
        # Compute the jaccard distance for the current pair
        jaccardindex = jaccard(malwareattributes[malware1], malwareattributes[malware2], 'api')
        node1 = malware1.split('/')[-1]
        node2 = malware2.split('/')[-1]

        # Determine file types to use appropriate jaccard index value
        malware1type = magic.from_file(malware1, mime=True)
        malware2type = magic.from_file(malware2, mime=True)

        if comparefiletypes(malware1type, malware2type):
            try:
                jaccardthreshold = thresholddict[malware1type]
            except KeyError as e:
                print("[*] Jaccard Index for filetype: " + str(malware1type) +" not available. Skipping...")
                continue
        else:
            #print("Different file signatures detected: " + str(malware1type) + \
            #      "," + str(malware2type))
            # Two malware of different file types cannot possibly be related
            continue

        # If the jaccard index is above `jaccardthreshold`, add an edge
        if jaccardindex > jaccardthreshold:
            graph.add_edge(node1, node2, penwidth = 1 + (jaccardindex - jaccardthreshold) * 10)

    return graph

def handlenonexe(documentsamples, thresholddict, graph):
    """
    Form edges between non-exe samples based on the `strings` attribute

    Args:
        documentsamples: absolute paths of all non-exe malware samples
        thresholddict  : dict containing Jaccard Index threshold values
        graph          : networkx graph object

    Raises:
        None

    Returns:
        graph: populated networkx graph object
    """

    # Get shelve database object
    db = getdatabase()

    malwareattributes = dict()

    # Get attributes and create node
    for path in documentsamples:
        # Get `strings` for `path` sample from shelve db and store them
        malwareattributes[path] = db[path]

        # Add each malware sample to the graph as a node. The label of the
        # node is equal to the first six chars of SHA256 hash of the sample
        graph.add_node(path.split('/')[-1], label=os.path.split(path)[-1][:6])

    # Create edge based on Jaccard index
    for malware1, malware2 in itertools.combinations(documentsamples, 2):
        # Compute the jaccard distance for the current pair
        jaccardindex = jaccard(malwareattributes[malware1], malwareattributes[malware2])

        # Determine file types to use appropriate jaccard index value
        malware1type = magic.from_file(malware1, mime=True)
        malware2type = magic.from_file(malware2, mime=True)

        if comparefiletypes(malware1type, malware2type):
            try:
                jaccardthreshold = thresholddict[malware1type]
            except KeyError as e:
                print("[*] Jaccard Index for filetype not available. Skipping...")
                continue
        else:
            #print("Different file signatures detected: " + str(malware1type) + \
            #      "," + str(malware2type))
            # Two malware of different file types cannot possibly be related
            continue

        # If the jaccard  is above `jaccardthreshold`, then add an edge
        if jaccardindex > jaccardthreshold:
            node1 = malware1.split('/')[-1]
            node2 = malware2.split('/')[-1]
            graph.add_edge(node1, node2, penwidth = 1 + (jaccardindex - jaccardthreshold) * 10)

    return graph

def formrelations(malwarepaths, thresholddict, ngram, graph):
    """
    Create edges between malware nodes based on their jaccard indices
    Document files like XLS, HTML, etc. will use `strings` attributes while
    PE files will use dynamic API calls attributes extracted from cuckoo

    Args:
        malwarepaths : absolute path of all malware samples
        thresholddict: dict containing Jaccard Index threshold values
        ngram        : ngram api sequence
        graph        : networkx graph object

    Raises:
        None

    Returns:
        graph: Populated networkx graph object
    """

    exesamples = []
    documentsamples = []

    # Separate EXE and non-EXE malware samples
    for sample in malwarepaths:
        if pecheck(sample):
            exesamples.append(sample)
        else:
            documentsamples.append(sample)

    # Form relations for non-exe files
    if documentsamples:
        graph = handlenonexe(documentsamples, thresholddict, graph)

    # Form relations for exe files
    if exesamples:
        graph = handleexe(exesamples, thresholddict, ngram, graph)

    return graph
